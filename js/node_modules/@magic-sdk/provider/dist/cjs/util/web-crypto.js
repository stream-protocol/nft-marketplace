"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var storage_1 = require("./storage");
var uuid_1 = require("./uuid");
exports.STORE_KEY_PRIVATE_KEY = 'STORE_KEY_PRIVATE_KEY';
exports.STORE_KEY_PUBLIC_JWK = 'STORE_KEY_PUBLIC_JWK';
var ALGO_NAME = 'ECDSA';
var ALGO_CURVE = 'P-256';
var EC_GEN_PARAMS = {
    name: ALGO_NAME,
    namedCurve: ALGO_CURVE,
};
var EC_IMPORT_PARAMS = {
    name: ALGO_NAME,
    namedCurve: ALGO_CURVE,
};
function getCryptoClient() {
    return window.crypto;
}
function clearKeys() {
    storage_1.removeItem(exports.STORE_KEY_PUBLIC_JWK);
    storage_1.removeItem(exports.STORE_KEY_PRIVATE_KEY);
}
exports.clearKeys = clearKeys;
function createJwt() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var publicJwk, crypto, privateJwk, claims, headers, jws, data, sigType, sig, _a, _b;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, getPublicKey()];
                case 1:
                    publicJwk = _c.sent();
                    if (!publicJwk) {
                        console.info('unable to create public key');
                        return [2 /*return*/, undefined];
                    }
                    crypto = getCryptoClient();
                    return [4 /*yield*/, storage_1.getItem(exports.STORE_KEY_PRIVATE_KEY)];
                case 2:
                    privateJwk = _c.sent();
                    if (!privateJwk || !crypto) {
                        console.info('unable to find private key or webcrypto unsupported');
                        return [2 /*return*/, undefined];
                    }
                    claims = {
                        iat: Math.floor(new Date().getTime() / 1000),
                        jti: uuid_1.uuid(),
                    };
                    headers = {
                        typ: 'dpop+jwt',
                        alg: 'ES256',
                        jwk: publicJwk,
                    };
                    jws = {
                        protected: strToUrlBase64(JSON.stringify(headers)),
                        claims: strToUrlBase64(JSON.stringify(claims)),
                    };
                    data = strToUint8(jws.protected + "." + jws.claims);
                    sigType = { name: ALGO_NAME, hash: { name: 'SHA-256' } };
                    _a = uint8ToUrlBase64;
                    _b = Uint8Array.bind;
                    return [4 /*yield*/, crypto.subtle.sign(sigType, privateJwk, data)];
                case 3:
                    sig = _a.apply(void 0, [new (_b.apply(Uint8Array, [void 0, _c.sent()]))()]);
                    return [2 /*return*/, jws.protected + "." + jws.claims + "." + sig];
            }
        });
    });
}
exports.createJwt = createJwt;
function getPublicKey() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!isWebCryptoSupported()) {
                        console.info('webcrypto is not supported');
                        return [2 /*return*/, undefined];
                    }
                    return [4 /*yield*/, storage_1.getItem(exports.STORE_KEY_PUBLIC_JWK)];
                case 1:
                    if (!!(_a.sent())) return [3 /*break*/, 3];
                    return [4 /*yield*/, generateWCKP()];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3: return [2 /*return*/, storage_1.getItem(exports.STORE_KEY_PUBLIC_JWK)];
            }
        });
    });
}
function generateWCKP() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var crypto, subtle, kp, jwkPrivateKey, jwkPublicKey, nonExportPrivateKey;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    crypto = getCryptoClient();
                    subtle = crypto.subtle;
                    return [4 /*yield*/, subtle.generateKey(EC_GEN_PARAMS, true, // need to export the public key which means private exports too
                        ['sign'])];
                case 1:
                    kp = _a.sent();
                    return [4 /*yield*/, subtle.exportKey('jwk', kp.privateKey)];
                case 2:
                    jwkPrivateKey = _a.sent();
                    return [4 /*yield*/, subtle.exportKey('jwk', kp.publicKey)];
                case 3:
                    jwkPublicKey = _a.sent();
                    return [4 /*yield*/, subtle.importKey('jwk', jwkPrivateKey, EC_IMPORT_PARAMS, false, ['sign'])];
                case 4:
                    nonExportPrivateKey = _a.sent();
                    // persist keys
                    return [4 /*yield*/, storage_1.setItem(exports.STORE_KEY_PRIVATE_KEY, nonExportPrivateKey)];
                case 5:
                    // persist keys
                    _a.sent();
                    // persist the jwk public key since it needs to be exported anyways
                    return [4 /*yield*/, storage_1.setItem(exports.STORE_KEY_PUBLIC_JWK, jwkPublicKey)];
                case 6:
                    // persist the jwk public key since it needs to be exported anyways
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function isWebCryptoSupported() {
    var hasCrypto = typeof window !== 'undefined' && !!window.crypto;
    var hasSubtleCrypto = hasCrypto && !!window.crypto.subtle;
    return hasCrypto && hasSubtleCrypto;
}
function strToUrlBase64(str) {
    return binToUrlBase64(utf8ToBinaryString(str));
}
function strToUint8(str) {
    return new TextEncoder().encode(str);
}
function binToUrlBase64(bin) {
    return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+/g, '');
}
function utf8ToBinaryString(str) {
    var escstr = encodeURIComponent(str);
    // replaces any uri escape sequence, such as %0A,
    // with binary escape, such as 0x0A
    return escstr.replace(/%([0-9A-F]{2})/g, function (_, p1) { return String.fromCharCode(parseInt(p1, 16)); });
}
function uint8ToUrlBase64(uint8) {
    var bin = '';
    uint8.forEach(function (code) {
        bin += String.fromCharCode(code);
    });
    return binToUrlBase64(bin);
}
//# sourceMappingURL=web-crypto.js.map